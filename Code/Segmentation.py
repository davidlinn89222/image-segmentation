import os# Change the current sys pathos.chdir("/Users/davidlin/Desktop/School/Master/2021_secondSem/SC/image-segmentation/")from os import walkfrom Code.lib import toolsimport numpy as npfrom skimage import segmentation, colorfrom hmmlearn import hmmimport matplotlib.pyplot as pltimport seaborn as sns; sns.set()from sklearn.cluster import KMeans, SpectralClusteringfrom time import timeimport cv2from PIL import Image# ---------------------------------------------------------------------------------------#######################################################################                                                              ###### Part 1:  Vector Quantization using K-means with different K  ######                                                              ######################################################################## K-means for VQ# Specify the number of colors n1_colors = 5n2_colors = 10n3_colors = 64# Load the photo and convert from BGR to RGB modelimg_bgr = cv2.imread("./Images/shiba.jpeg")img = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)# Converts to float instead of integer and divided by 255img = np.array(img, dtype = np.int32) / 255# Transform to a 2D numpy arrayw, h, d = original_shape = tuple(img.shape)img_arr = np.reshape(img, (w*h, d))### Fitting K-means t0 = time()kmeans_5 = KMeans(n_clusters = n1_colors, random_state = 0).fit(img_arr)kmeans_10 = KMeans(n_clusters = n2_colors, random_state = 0).fit(img_arr)kmeans_64 = KMeans(n_clusters = n3_colors, random_state = 0).fit(img_arr)print("K-means is done in %0.3fs." % (time() - t0))# Display the clustering results and save themfig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(img)fig.savefig('./Cluster_results/Shiba/Shiba.png', dpi = 300)fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(tools.recreate_image(kmeans_5.cluster_centers_, kmeans_5.labels_, w, h))fig.savefig('./Cluster_results/Shiba/Shiba_kmeans_5.png', dpi = 300)fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(tools.recreate_image(kmeans_10.cluster_centers_, kmeans_10.labels_, w, h))fig.savefig('./Cluster_results/Shiba/Shiba_kmeans_10.png', dpi = 300)fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(tools.recreate_image(kmeans_64.cluster_centers_, kmeans_64.labels_, w, h))fig.savefig('./Cluster_results/Shiba/Shiba_kmeans_64.png', dpi = 300)# ------------------------------------------------------------------------------------------------------------###############################################################                                                      ###### Part 2: Brain Tumor Segmentation: demo               ######                                                      ################################################################## number of clustersn_colors = 4# Load the photo and convert from BGR to RGB modelimg_bgr = cv2.imread("./Images/brain.jpeg")img = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)# Transform to a 2D numpy arrayw, h = original_shape = tuple(img.shape)# Resize the photoscale_percent = 0.1dim = int(w * scale_percent), int(h * scale_percent)img = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)# Converts to float instead of integer and divided by 255img = np.array(img, dtype = np.int32) / 255img_arr = np.reshape(img, (dim[0]*dim[1], 1))# Visualize the brain image fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(img, cmap = "gray")fig.savefig('./Cluster_results/MRI/MRI.png', dpi = 300)### Fitting K-meanst0 = time()kmeans = KMeans(n_clusters = n_colors, random_state = 0).fit(img_arr)print("K-means is done in %0.3fs." % (time() - t0))# Visualize result of K-meansfig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))out_kmeans = tools.recreate_image(kmeans.cluster_centers_, kmeans.labels_, dim[1], dim[0])ax.imshow(out_kmeans, cmap = "gray")fig.savefig('./Cluster_results/MRI/MRI_kmeans.png', dpi = 300)### Fitting Spectral Clusteringt0 = time()spec = SpectralClustering(n_clusters = n_colors, assign_labels = "kmeans", verbose= True).fit(img_arr)print("Spectral clustering done in %0.3fs." % (time() - t0))# Index image from Spectral clusteringspec_idx_img = np.reshape(spec.labels_, (dim[1], dim[0]))# Iterate all colors in mask# for color in np.unique(spec_idx_img):        # Color 0 is assumed to be background or artifacts    # if color == :    #     continue        # Determine bounding box rectangle with relate to all pixels the idx_img with the current color    # x, y, w, h = cv2.boundingRect(np.uint8(spec_idx_img == color))            # Draw bounding rectangle to color image     # out = cv2.rectangle(img.copy(), (x, y), (x+w, y+h), (0, int(color), 0, 2))        # Show image with bounding box    # fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))    # ax.imshow(out, cmap = "gray")out1 = color.label2rgb(spec_idx_img, img, kind='avg', bg_label = 0)# Visualize result of Spectral Clusteringfig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(out1, cmap = "gray")fig.savefig('./Cluster_results/MRI/MRI_spec.png', dpi = 300)fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))out_border = segmentation.mark_boundaries(out1, np.reshape(spec.labels_, (dim[1], dim[0])), mode = "subpixel")ax.imshow(out_border, cmap = "gray")fig.savefig('./Cluster_results/MRI/MRI_spec_subpixel.png', dpi = 300)### Fitting HMMt0 = time()hm = hmm.GaussianHMM(n_components = n_colors, covariance_type = "full").fit(img_arr)print("HMM is done in %0.3fs." % (time() - t0))hm_labels = hm.predict(img_arr)out_hmm = tools.recreate_image(hm.means_, hm_labels, dim[1], dim[0])# Visualize result of hmmfig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))ax.imshow(out_hmm, cmap = "gray")fig.savefig('./Cluster_results/MRI/MRI_hmm.png', dpi = 300)# ------------------------------------------------------------------------------------------------------------------###############################################################                                                      ###### Part 3: Brain Tumor Segmentation: sets of image      ######                                                      ################################################################ Specify the directory of MRI imagesimg_dir = "./Images/MRI/"# Filenames inside img_dir_, _, filenames = next(walk(img_dir))# Exceute Spectral clustering for all imagesn_colors = 3cluster_results = []for i in range( len(filenames) ):        # Load the photo and convert from BGR to GRAY model     img = cv2.imread(img_dir + filenames[i])    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)        # Specify the dimensions of the image    w, h = original_shape = tuple(img.shape)        # Compress the pixel value within [0, 1]    img = np.array(img, dtype = np.int32) / 255        # Resize the photo with 150x150    dim = 150, 150    img = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)        # Reshape it to 1-d array     img_arr = np.reshape(img, (dim[0]*dim[1], 1))        # Store the proccessed photo    fig, ax = plt.subplots(1, 1, figsize = (10, 10), subplot_kw = dict(xticks=[], yticks=[]))    ax.imshow(img, cmap = "gray")    fig.savefig('./Cluster_results/MRI_multi/' + "original" + str(i+1) + ".png", dpi = 400)        # Fitting spectral clustering    t0 = time()    spec = SpectralClustering(n_clusters = n_colors, assign_labels = "kmeans", verbose= True).fit(img_arr)    print("Spectral clustering done in %0.3fs." % (time() - t0))    out = color.label2rgb(np.reshape(spec.labels_, (dim[1], dim[0])), img, kind='avg')    cluster_results.append(out)        s