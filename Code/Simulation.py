import os# Change the current sys pathos.chdir("/Users/davidlin/Desktop/School/Master/2021_secondSem/SC/image-segmentation/")from Code.lib import generators, toolsimport numpy as npimport matplotlib.pyplot as pltimport seaborn as sns; sns.set()import pandas as pdfrom sklearn.cluster import KMeans, DBSCANfrom sklearn.mixture import GaussianMixturefrom sklearn.datasets import make_moonsfrom sklearn import metrics# ===============================================================================================### Scenario 1: Simulate three clusters, each of them is 2-d independent bivariate normal distribution# number of clustersnum_clusters = 3# sample sizen = 1000# Specify three mean vectors for these clustersmu1 = np.array([1, 2]).reshape(2, 1)mu2 = np.array([18, 5]).reshape(2, 1)mu3 = np.array([5, 15]).reshape(2, 1)mu = [mu1, mu2, mu3]# Specify three covariance matrix for these clustersSigma1 = np.array([[2, 0], [0, 2]])Sigma2 = np.array([[2, 0], [0, 1]])Sigma3 = np.array([[5, 0], [0, 4]])Sigma = [Sigma1, Sigma2, Sigma3]# Generate cluster data df = generators.clusters_norm_generator(n, num_clusters, mu, Sigma, seed = 123)# Visualization for the clustersp = sns.jointplot(data = df, x = "x1", y = "x2", hue = "Clust", palette = "deep")p.savefig("./Simu_results/sen1.png", dpi=400)# Modeling using Kmeans, GMM and DBSCAN# Initialize KMeans, GaussianMixture Model and DBSCAN# Kmeanskmeans = KMeans(n_clusters = 3, max_iter = 100000, tol = 1e-6)# GMMgm = GaussianMixture(n_components = 3, max_iter = 100000, tol = 1e-6, init_params = 'kmeans')# DBSCANtools.optimal_eps_DBSCAN(df.drop("Clust", axis = 1).values, 4) # 0.5dbscan = DBSCAN(eps = 1.5, min_samples = 4)# Fit and predict the algorithmsy_kmeans = kmeans.fit_predict(df.drop("Clust", axis = 1))y_gm = gm.fit_predict(df.drop("Clust", axis = 1))y_dbscan = dbscan.fit_predict(df.drop("Clust", axis = 1))# New dfdf_preds = df.copy()df_preds["preds_Kmeans"] = y_kmeansdf_preds["preds_GMM"] = y_gmdf_preds['preds_DBSCAN'] = y_dbscan# ===============================================================================================### Scenario 2: Simulate three clusters, each of them is 2-d non-indep bivariate normal distribution# number of clustersnum_clusters = 3# sample sizen = 1000# Specify three mean vectors for these clustersmu1 = np.array([1, 2]).reshape(2, 1)mu2 = np.array([20, 20]).reshape(2, 1)mu3 = np.array([10, 20]).reshape(2, 1)mu = [mu1, mu2, mu3]# Specify covariance matrix for these clustersSigma1 = np.array([[6, 6], [6, 8]])Sigma2 = np.array([[6, 6], [6, 8]])Sigma3 = np.array([[6, 6], [6, 8]])Sigma = [Sigma1, Sigma2, Sigma3]# Generate cluster data df2 = generators.clusters_norm_generator(n, num_clusters, mu, Sigma, seed = 123)# Visualization for the clustersp = sns.jointplot(data = df2, x = "x1", y = "x2", hue = "Clust", palette = "deep")p.savefig("./Simu_results/sen2.png", dpi=400)# Modeling using Kmeans and GMM# Initialize KMeans and GaussianMixture models# Kmeanskmeans = KMeans(n_clusters = 3, max_iter = 100000, tol = 1e-6)# GMMgm = GaussianMixture(n_components = 3, max_iter = 100000, tol = 1e-6, init_params='kmeans')# DBSCANtools.optimal_eps_DBSCAN(df2.drop("Clust", axis = 1).values, 4) # 1.5dbscan = DBSCAN(eps = 1.5, min_samples = 4)# Fit and predict the algorithmsy_kmeans = kmeans.fit_predict(df2.drop("Clust", axis = 1))y_gm = gm.fit_predict(df2.drop("Clust", axis = 1))y_dbscan = dbscan.fit_predict(df2.drop("Clust", axis = 1))# New dfdf2_preds = df2.copy()df2_preds["preds_Kmeans"] = y_kmeansdf2_preds["preds_GMM"] = y_gmdf2_preds['preds_DBSCAN'] = y_dbscan# ===============================================================================================### Scenario 3: moons structure data with noise from make_moons() in sklearn module# sample sizen = 1000# Simulate data from make_noon with noise = 0.08 varX, y = make_moons(n_samples = n, noise = .08)df3 = pd.DataFrame(X, columns = ["x1", "x2"])df3['Clust'] = y# Visualization for the clustersp = sns.jointplot(data = df3, x = "x1", y = "x2", hue = "Clust", palette = "deep")p.savefig("./Simu_results/sen3.png", dpi=400)# Modeling using Kmeans and GMM# Initialize KMeans and GaussianMixture models# Kmeanskmeans = KMeans(n_clusters = 2, max_iter = 10**4, tol = 1e-6)# Gaussian Mixed Modelgm = GaussianMixture(n_components = 2, max_iter = 10**4, tol = 1e-6, init_params = 'random')# DBSCANtools.optimal_eps_DBSCAN(df3.drop("Clust", axis = 1).values, 4) # 0.15dbscan = DBSCAN(eps = 0.15, min_samples = 4)# Fit and predict the algorithmsy_kmeans = kmeans.fit_predict(df3.drop("Clust", axis = 1))y_gm = gm.fit_predict(df3.drop("Clust", axis = 1))y_dbscan = dbscan.fit_predict(df3.drop("Clust", axis = 1))# New dfdf3_preds = df3.copy()df3_preds["preds_Kmeans"] = y_kmeansdf3_preds["preds_GMM"] = y_gmdf3_preds["preds_DBSCAN"] = y_dbscan# -----------------------------------------------------------------------------------------------------------------------------# Performance and visualization of simulation resultssim_list = [df_preds, df2_preds, df3_preds]labels = ["Clust", "preds_Kmeans", "preds_GMM", "preds_DBSCAN"]texts_md = ["True cluts", "Kmeans", "GMM", "DBSCAN"]texts_dt = ["scenario 1", "scenario 2", "scenario 3"]fig, axes = plt.subplots(4, 3, figsize=(10, 8))for i in range(len(sim_list)):       dt = sim_list[i]    for j in range(4):        temp = sns.scatterplot(ax=axes[j, i], data = dt, x = "x1", y = "x2", hue = labels[j], palette = "deep")        temp.get_legend().remove()        temp.set_title(texts_md[j] + " in " + texts_dt[i])        temp.set(xticklabels=[])        temp.set(yticklabels=[])        temp.set(xlabel=None)        temp.set(ylabel=None)fig.savefig("/Simu_results/results.png", dpi = 400)        # Rand index# Rand index is a function that measures the similarity of the two assignments, ignoring permutations:with open("./Simu_results/rand_score.txt", "w") as f:    i = 1    for dt in sim_list:        j = 1        for md in labels[1:]:            rand_sc = round(metrics.rand_score(dt["Clust"], dt[md]), 4)            print("The rand score for {} in scenario {} is {}".format(texts_md[j], i, rand_sc), file=f)            j+=1        i+=1    